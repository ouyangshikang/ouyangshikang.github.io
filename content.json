{"meta":{"title":"心猿意码","subtitle":"白陀的前端学习分享","description":"白陀的前端学习分享","author":"baituo","url":"https://frontman.cn"},"pages":[{"title":"标签","date":"2018-03-06T14:39:01.000Z","updated":"2024-07-09T02:27:50.202Z","comments":false,"path":"tags/index.html","permalink":"https://frontman.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"js数值精度问题及es6数值的拓展","slug":"js-precision-es6-number","date":"2018-03-01T14:20:35.000Z","updated":"2024-07-09T02:27:50.202Z","comments":true,"path":"2018/03/01/js-precision-es6-number/","link":"","permalink":"https://frontman.cn/2018/03/01/js-precision-es6-number/","excerpt":"","text":"js的数值精度问题 在js内部，整数和浮点数采用同样的存储方法(64位双精度浮点数)，所以有66 === 66.00。 在涉及小数的运算时要注意数值精度的问题,举个人尽皆知的栗子\b🌰120.1 + 0.2 === 0.3 // false0.1 + 0.2 // 0.30000000000000004 \bJavaScript采用国际标准 IEEE 754，JavaScript浮点数的64个二进制位，从最左边开始，是这样组成的: 第1位：符号位，0表示正数，1表示负数 第2位到第12位(11)：指数部分 第13位到第64位(52)：小数部分（即有效数字） 符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度 国际标准IEEE 754 规定，有效数字第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字总是1.xx...xx的形式，其中xx..xx的部分保存在64位浮点数之中，最长可能为52位。因此，JavaScript 提供的有效数字最长为53个二进制位。 所以，一个数在 JavaScript 内部实际的表示形式为: 精度最多只能到53个二进制位，这意味着，绝对值小于2的53次方的整数，即-(2^53-1) ~ 2^53-1，都可以精确表示。 1234Math.pow(2, 53); // 9007199254740992Math.pow(2, 53) + 1; //9007199254740992Math.pow(2, 53) + 2; // 90071992547409949007199254740992222 // 9007199254740992000 大于2的53次方后，计算结果就开始混乱了，无法保持精度,并且多出的三个有效位无法保存，变成0。 ES6中2进制和8进制的表示 二进制数值：前缀0b/0B 八进制数值：前缀0o/0O12console.log('二进制表示法:', 0b00010 === 2); // trueconsole.log('八进制表示法:', 0o0340 === 224); // true 将各进制转为10进制用Number()/ parseInt()方法,将10进制转化为各进制可以用toString(n)方法 Number对象拓展es6在Number对象上，新增了2个方法。 Number.isFinite() 检查数值是否是有限的，如果不是数值，返回false 123456console.log(Number.isFinite(15)); // trueconsole.log(Number.isFinite(true)); // falseconsole.log(Number.isFinite(0.8)); // trueconsole.log(Number.isFinite(NaN)); // falseconsole.log(Number.isFinite('string')); // falseconsole.log(Number.isFinite(Infinity)); // false Number.isNaN() 检测数值是否为NaN， 如果不是数值，也返回false 12345console.log(Number.isNaN(15)); // falseconsole.log(Number.isNaN(true)); // falseconsole.log(Number.isNaN('NaN')); // falseconsole.log(Number.isNaN(NaN)); // trueconsole.log(Number.isNaN(0.4)); // false 它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断。而这两个新方法只对数值有效。 先进行是否是数值的判断，是数值再进行具体判断。 ES6将全局方法parseInt()和parseFloat()移植到Number对象上，其他都保持不变 Number.isInteger() 判断一个数值是否为整数 12345console.log(Number.isInteger(66)); // trueconsole.log(Number.isInteger(66.0)); // trueconsole.log(Number.isInteger(66.6)); // falseconsole.log(Number.isInteger(null)); // falseconsole.log(Number.isInteger('nice')); // false Number.EPSILON 它表示 1 与大于 1 的最小浮点数之间的差即2的-52次方,这是JavaScript能够表示的最小精度 1console.log(Number.EPSILON === Math.pow(2, -52)); // true","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://frontman.cn/tags/javascript/"}]},{"title":"git commit 基本规范","slug":"git-commit-standards","date":"2017-06-06T13:45:18.000Z","updated":"2024-07-09T02:40:40.040Z","comments":true,"path":"2017/06/06/git-commit-standards/","link":"","permalink":"https://frontman.cn/2017/06/06/git-commit-standards/","excerpt":"","text":"简单介绍下 git commit 的规范。 我们每次进行 git 提交的时候，git commit 都包括三个部分： header body footer header 是必须的,body 和 footer 经常可以省略 Headerheader 部分就只有一行(不超过 72 个字符), 包括三个字段type(必须)，scope(可选)，subject(必须) 1&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt; type: 12345678910feat： 增加新功能（feature）fix： 修补bugdocs： 仅仅修改了文档，比如说README,CHANGELOG等等style： 修改了空格，格式缩进，样式格式（不改变代码逻辑的变动）refactor：重构（即不是新增功能，也不是修改bug的代码变动）test： 增加测试，包括单元测试等perf： 优化相关，比如提升了性能，体验等chore： 构建过程或辅助工具的变动revert： 回滚到上一个版本build： Build System | 构建 scope:scope 用作说明 commit 的影响范围。 subject:subject 是对 commit 的简短说明。 123以动词开头第一个字母小写结尾没有句号","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://frontman.cn/tags/git/"}]},{"title":"javascript中的深拷贝和浅拷贝","slug":"deepCopy","date":"2017-05-21T15:12:06.000Z","updated":"2024-07-09T02:27:50.202Z","comments":true,"path":"2017/05/21/deepCopy/","link":"","permalink":"https://frontman.cn/2017/05/21/deepCopy/","excerpt":"","text":"区别浅拷贝 对于字符串类型，浅拷贝是对值的复制; 对于对象或数组来说，浅拷贝是对对象地址的复制，并没有开辟新的栈。就是将一个对象的内存地址的“编号”拷贝给另一个对象。只复制一层对象的属性. 深拷贝 实现原理: 先新建一个空对象，内存中新开辟一块地址，把被复制对象的所有可枚举的(注意可枚举的对象)属性方法一一复制过来，注意要用递归来复制子对象里面的所有属性和方法，直到子子…..属性为基本数据类型。 总结 深拷贝理解两点:1. 新开辟内存地址，2,递归来刨根复制。 实现浅拷贝在Javascript 中，将一个对象赋值给一个变量其实只是将这个对象的引用拷贝了一份假设这么一段代码12345var man = &#123; name: 'aepkill', sex: 'male'&#125;;var superMan = man; 并没有创建一个新的对象实体，而是仅仅拷贝了这种引用关系。所以假设执行 man.name = ‘aotuman’ ，那么superMan.name的值也会变成 ‘aotuman’，因为其实他们引用的是同一个对象实体。 很多场景下并不希望出现像上面中那样， 我们希望能使两个变量相互独立，不再引用同一个对象这很容易实现，只需要申明一个新的对象，然后将这个对象的所有字段原封不动拷贝过去即可： 1234567891011121314151617181920function copy(obj)&#123; //创建一个新对象 let newObj = &#123;&#125;; //返回keys数组，包含obj所有可枚举的自身属性名 let keys = Object.keys(obj),key=null; for(let i =0;i&lt;keys.length;i++)&#123; key = keys[i]; //将obj所有属性复制到新对象 newObj[key] = obj[key]; &#125; return newObj;&#125;var people = &#123; name:'java', age:22&#125;var hero = copy(people);people.name = 'javascript';console.log(people.name); //javascriptconsole.log(hero.name); // java 两个变量已经不在引用同一个对象，二者的修改是相互独立的 深拷贝上面已经完成了基本的拷贝，但是只拷贝了第一层的关系，如果对象不止一层的话，上面的函数就不适用了： 123456789101112var people = &#123; name: 'java', age: 22, concat:&#123; tel:'1568552256', qq:'54666651' &#125;&#125;var hero = copy(people);people.concat.tel = '1111111111';console.log(people.concat.tel); //1111111111console.log(hero.concat.tel); // 1111111111 因为只拷贝了一层，所以people 与 hero 中的concat 字段还是引用同一个对象，所以当执行 people.concat.tel = ‘1111111111’ 后，hero .concat.tel 也变成了 ‘1111111111 ‘ ，该如何解决这个问题呢？ 此时，需要对这个问题进行梳理并抽象：定义一个函数deepCopy，该函数遍历传入的对象，如果该字段的值不是一个对象则可直接赋值给新对象，否则对该字段用函数deepCopy进行递归操作。 123456789101112131415161718192021222324252627282930function deepCopy(obj) &#123; let newObj = &#123;&#125; let keys = Object.keys(obj), key = null, temp = null; for (let i = 0; i &lt; keys.length; i++) &#123; key = keys[i]; temp = obj[key]; // 如果字段的值也是一个对象则递归操作 if (temp &amp;&amp; typeof temp === 'object') &#123; newObj[key] = deepCopy(temp); &#125; else &#123; // 否则直接赋值给新对象 newObj[key] = temp; &#125; &#125; return newObj;&#125;var people = &#123; name: 'java', age: 22, concat: &#123; tel: '1568552256', qq: '54666651' &#125;&#125;var hero = deepCopy(people);people.concat.tel = '1111111111';console.log(people.concat.tel);//1111111111console.log(hero.concat.tel);// 1568552256 OK,deepCopy 函数可以拷贝任意深度的对象了","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://frontman.cn/tags/javascript/"}]},{"title":"搞懂this及相关问题","slug":"about-this","date":"2017-05-12T14:49:39.000Z","updated":"2024-07-09T02:27:50.202Z","comments":true,"path":"2017/05/12/about-this/","link":"","permalink":"https://frontman.cn/2017/05/12/about-this/","excerpt":"","text":"this的使用场合 全局环境下使用，指的是顶层对象 window 构造函数中的this，指的是实例对象 对象的方法 当A对象的方法赋予给另一个B对象，该方法中的this指向就变成B 照常举个栗子:12345678let obj = &#123; foo() &#123; console.log(this); &#125;&#125;let bar = obj.foo;obj.foo() // 打印出的 this 是 objbar() // 打印出的 this 是 window 为什么呢？解决这类问题需要理解函数的调用问题，js里有三种函数的调用方式： func(a,b); obj.child.method(a,b); func.call(context,a,b);func.apply(context,[a,b]); //context为函数执行环境的上下文 但其实前两种都可以转化为第三种(以call的形式)： func.call(undefine, a,b); obj.child.method.call(obj.child,a,b); 所以，栗子可以吃了:12obj.foo(); -----&gt; obj.foo.call(obj);bar(); -----&gt; bar.call(undefined); 在浏览器中，如果context传入的值为undefined，null, 还有空值 ，那么默认的就是window 当然，如果你想让bar()的context指向obj,那就直接bar.call(obj),指定当前context(函数内部的this)绑定到obj上 总结一句话：函数在哪里被调用，this就指向哪里 绑定this的方法(call,apply,bind的区别) call与apply两者对于参数的接受方式不同,call接受的是参数列表，apply接受的是一个包含多个参数的数组 apply的语法： fun.apply(thisArg[, argsArray])如xxx.apply(undefined, [1,2,3]) call的语法：fun.call(thisArg[, arg1[, arg2[, ...])如xxx.call(undefined, 1,2,3]) bind和call,apply的作用一样，动态指定this,不同在于返回值,bind可以强制指定this到某个对象，还可以绑定原函数的参数,然后返回一个新函数，之后不会修改，即预设了对象的this和参数 看下面bind的demo1234567891011121314151617181920212223242526272829303132var counter = &#123; count: 0, inc: function () &#123; this.count++; &#125;&#125;;counter.count // 0counter.inc()counter.count // 1/** * counter.inc内部的this，默认指向counter对象。 * 如果将这个方法赋值给另一个变量，就会出错,如下： */var counter = &#123; count: 0, inc: function () &#123; this.count++; &#125;&#125;;var func = counter.inc;func();counter.count // 0count // NaN/** 函数func是在全局环境中运行的，这时inc内部的this指向顶层对象window， * 所以counter.count是不会变的，反而创建了一个全局变量count。 * 因为window.count原来等于undefined，进行递增运算后undefined++就等于NaN。 */// 可以使用bind方法，将inc内部的this绑定到counter对象var func = counter.inc.bind(counter);func();counter.count // 1 绑定原函数的参数这里不再赘述。 关于this的题目：12345678var john = &#123; firstName: \"John\" &#125;;function func() &#123; alert(this.firstName + \": hi!\")&#125;; john.sayHi = func; john.sayHi(); //john.sayHi()的this指向john因此输出\"John:hi!\" 1234567document.addEventListener('click', function(e)&#123; console.log(this);// this指向document setTimeout(function()&#123; console.log(this);//this指向window &#125;, 200);&#125;, false);//分别输出document和window 12345678var john = &#123; firstName: \"John\";&#125;;function func() &#123; alert( this.firstName )&#125;;func.call(john);//输出John,因为func.call(john)将func的this指向了john对象 123456789101112var module= &#123; bind: function()&#123; var _this = this //将当前this保存 $btn.on('click', function()&#123; console.log(_this) //this指向$btn _this.showMsg();//$btn没有showMsg()方法 &#125;) &#125;, showMsg: function()&#123; console.log('nice'); &#125;&#125;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://frontman.cn/tags/javascript/"}]},{"title":"原型链的理解","slug":"learn-prototype","date":"2017-05-10T15:26:27.000Z","updated":"2024-07-09T02:27:50.202Z","comments":true,"path":"2017/05/10/learn-prototype/","link":"","permalink":"https://frontman.cn/2017/05/10/learn-prototype/","excerpt":"","text":"先给出个栗子吃12345678function Person(name)&#123; this.name = name;&#125;Person.prototype.sayName = function()&#123; console.log('My name is :' + this.name);&#125;var p = new Person(\"KK\")p.sayName(); 我们解释下 Person、p、prototype、proto、constructor之间的关系哦 Person是构造函数，p是Person的一个实例 所有的对象都有__proto__属性,只有函数有prototype 每个函数都有自己的原形对象 prototype， 而prototype中有__proto__和constructor, constructor顾名思义就是构造函数,__proto__就是是实例的原型链 在实例中，__proto__可看做是key,prototype可看做是value。xxx.proto === yyy.prototype 那么，在这个栗子中,可以得出这么些结论:12345Person.prototype.constructor == Person //truep.__proto__ === Person.prototype //truePerson.prototype.__proto__ === Object.prototype //trueObject.prototype.constructor == Object,Object.prototype.__proto__ == null 原型链的概念理解： 使用一个构造函数创造一个实例对象，在此对象上调用相应的属性和方法时，JS存在一个搜索机制，首先查找它本身有没有，如果没有，则顺着__ proto这个指针去找它的构造函数的原型上有没有，如果没有，再顺着原型的 proto__向上去找，也就是说，只要存在 proto这个指针，在没有找到对应的属性与方法时，查找不会停下，直到没有 proto为止，这样的一种形式可行的结构基础就叫 原型链 。 再给张图就更完美了： 关于原型的其他知识点instanceOf作用：用来检测一个对象的类型 instanceof运算符用来测试一个对象在其原型链中是否存在一个构造函数的prototype属性A instanceof B 表示A的的原型链中是否存在 B.prototype ： 有就return true,反之return false 1234567891011121314function Car(make, model, year) &#123; this.make = make; this.model = model; this.year = year;&#125;var mycar = new Car(\"Honda\", \"Accord\", 1998);var a = mycar instanceof Car;// 返回 true var b = mycar instanceof Object; // 返回 truevar simpleStr = \"This is a simple string\";var myString = new String();simpleStr instanceof String;// returns false, 检查原型链会找到 undefined，simpleStr不是对象myString instanceof String;// returns true Object.create() Object.create() 方法使用指定的原型对象和其属性创建了一个新的对象语法：Object.create(proto, [ propertiesObject ])// 第一个参数为一个对象，应该是新创建的对象的原型。作用： 创建一个新的对象,第一层原型链指向对应的参数1234var a = &#123;'age': 20&#125;var b = &#123;'name':'Jack'&#125;b = Object.create(a)b.__proto__ === a //true","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://frontman.cn/tags/javascript/"}]}]}